# Workflow name
name: TPVToggle - Version Bump and Release

# Permissions needed for the workflow to write contents (commits, tags, releases)
permissions:
  contents: write

# How the workflow is triggered: manually via GitHub UI ('workflow_dispatch')
on:
  workflow_dispatch:
    inputs:
      # User chooses which version part to bump (patch is default)
      version_part:
        description: "Version part to bump (major, minor, patch)"
        required: true
        default: "patch"
        type: choice
        options: [patch, minor, major] # Use array syntax
      # User can provide a custom title for the release notes
      version_title:
        description: "Release title (e.g., 'Camera Update') - overrides changelog title"
        required: false
        type: string
      # User can mark this release as a pre-release
      prerelease:
        description: "Mark as pre-release?"
        required: false
        default: false
        type: boolean

jobs:
  # Single job named 'bump-and-release'
  bump-and-release:
    # Runs on the latest Windows virtual environment provided by GitHub Actions
    runs-on: windows-latest
    steps:
      # 1. Checkout Repository Code
      - name: Checkout code
        uses: actions/checkout@v4 # Use latest version
        with:
          fetch-depth: 0 # Fetch all history for tagging/changelog generation
          submodules: "recursive" # Important if you add submodules (like DirectXMath source) later

      # 2. Set up Python Environment (for version_updater script)
      - name: Set up Python
        uses: actions/setup-python@v5 # Use latest version
        with:
          python-version: "3.11" # Choose appropriate Python version

      # 3. Read and Process NEXT_CHANGELOG.md
      - name: Read changelog from file
        id: read-changelog
        run: |
          $changelogPath = "TPVToggle/docs/NEXT_CHANGELOG.md"
          if (-not (Test-Path $changelogPath)) { echo "Error: $changelogPath not found."; exit 1 }
          $content = Get-Content $changelogPath -Raw -Encoding utf8
          $lines = $content -split "`r?`n" # Split by newline, handle Windows/Unix endings
          $title = $lines[0].Trim() -replace "^##\s+", ""
          if ([string]::IsNullOrEmpty($title)) { $title = "Update v${{ env.NEW_VERSION }}" } # Default title if empty
          # Join remaining lines, encoding newlines for multiline output variable
          $changelogBody = ($lines | Select-Object -Skip 1) -join "%0A"
          # Set outputs for use in later steps
          echo "SUGGESTED_TITLE=$title" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "CHANGELOG=$changelogBody" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "Read suggested title: $title"
        shell: pwsh

      # 4. Determine Final Release Title
      - name: Determine version title
        id: determine-title
        run: |
          $titleToUse = "${{ inputs.version_title }}"
          if ([string]::IsNullOrEmpty($titleToUse)) {
            $titleToUse = "${{ steps.read-changelog.outputs.SUGGESTED_TITLE }}"
            echo "Using title from changelog: '$titleToUse'"
          } else {
            echo "Using title from input: '$titleToUse'"
          }
          echo "TITLE=$titleToUse" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      # 5. Bump Version & Set Env Vars (Uses python script)
      - name: Bump version and update files
        id: bump
        run: |
          # Prepare changelog content for script argument (handle multiline/special chars)
          $changelogDecoded = '${{ steps.read-changelog.outputs.CHANGELOG }}' -replace '%0A', "`n"
          $tempChangelogFile = "temp_changelog_body.txt"
          Set-Content -Path $tempChangelogFile -Value $changelogDecoded -Encoding utf8
          echo "Running version updater script..."
          # Execute the script
          python TPVToggle/scripts/version_updater.py bump ${{ inputs.version_part }} --title "${{ steps.determine-title.outputs.TITLE }}" --changelogfile "$tempChangelogFile"
          if ($LASTEXITCODE -ne 0) { echo "Error running version_updater.py"; exit $LASTEXITCODE }
          Remove-Item -Path $tempChangelogFile # Clean up temp file

          # Read new version details from version.h
          $version_h = Get-Content TPVToggle\src\version.h -Raw
          $major = [regex]::Match($version_h, '#define\s+VERSION_MAJOR\s+(\d+)').Groups[1].Value
          $minor = [regex]::Match($version_h, '#define\s+VERSION_MINOR\s+(\d+)').Groups[1].Value
          $patch = [regex]::Match($version_h, '#define\s+VERSION_PATCH\s+(\d+)').Groups[1].Value
          $new_version = "$major.$minor.$patch"
          if (-not $new_version) { echo "Error: Could not parse new version from version.h"; exit 1}
          echo "New version detected: $new_version"

          # Set env vars accessible by later steps in the job
          echo "NEW_VERSION=$new_version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "VERSION_TAG=v$new_version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "ARTIFACT_NAME=KCD2_TPVToggle_${{ env.GITHUB_RUN_ID }}_v${new_version}.zip" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append # Add Run ID for uniqueness maybe?
        shell: pwsh

      # 6. Setup MinGW Build Environment using Chocolatey
      - name: Cache MinGW
        id: cache-mingw
        uses: actions/cache@v4
        with:
          path: C:\ProgramData\chocolatey\lib\mingw # Path where choco installs mingw
          key: ${{ runner.os }}-mingw-choco-8.1.0 # Key includes choco source and version

      - name: Install MinGW (if not cached)
        if: steps.cache-mingw.outputs.cache-hit != 'true'
        run: choco install mingw --version=8.1.0 -y --no-progress
        shell: powershell

      - name: Set MinGW bin Path environment variable
        run: echo "C:\ProgramData\chocolatey\lib\mingw\tools\install\mingw64\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        shell: powershell

      # 7. Build the ASI Plugin
      - name: Build ASI plugin with Make
        run: |
          cd TPVToggle # Navigate to the directory with the Makefile
          make clean   # Ensure clean build
          make         # Run the default build target
        shell: bash # Use bash (comes with Git install on windows runners) for make compatibility

      # 8. Copy Distribution Files (like ASI loader, READMEs, INI)
      # Assuming `make install` is configured to do this
      - name: Prepare distribution files
        run: |
          cd TPVToggle
          make install
        shell: bash

      # 9. Create ZIP Archive
      - name: Create ZIP archive for release
        run: |
          cd TPVToggle/build # Go into the directory prepared by 'make install'
          # Archive all files in 'build' into a zip in the repository root
          7z a ..\..\${{ env.ARTIFACT_NAME }} * -tzip # Explicitly use zip format
        shell: powershell

      # 10. Commit Version & Changelog Changes, Create Tag, Push
      - name: Commit version changes and tag release
        run: |
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add TPVToggle/src/version.h TPVToggle/CHANGELOG.md # Add files changed by script
          # Check if anything was staged before attempting commit
          if (git diff --staged --quiet --exit-code); then
            echo "No changes to commit for version bump."
          else
            git commit -m "ci(TPVToggle): Bump version to ${{ env.NEW_VERSION }}"
          fi
          # Always create the tag based on env var
          git tag -a TPVToggle-${{ env.VERSION_TAG }} -m "Release ${{ env.VERSION_TAG }}"
          # Push commit (if any) and the tag
          git push origin main --follow-tags
        shell: bash

      # 11. Prepare Release Body Notes
      - name: Prepare release notes body
        id: prepare-release
        run: |
          # Decode multiline changelog, use run ID/SHA for more info
          $changelogDecoded = '${{ steps.read-changelog.outputs.CHANGELOG }}' -replace '%0A', "`n"
          $repoUrl = "${{ github.server_url }}/${{ github.repository }}"
          $releaseBody = @"
          # KCD2 TPVToggle ${{ env.VERSION_TAG }}

          ${{ steps.determine-title.outputs.TITLE }}

          ## Changelog
          $changelogDecoded

          ---
          *Build commit: `${{ github.sha }}`*
          *Workflow run: `$repoUrl/actions/runs/${{ github.run_id }}`*
          ## Installation
          1. Ensure an ASI Loader (`dinput8.dll`) is in `<GameDir>/Bin/Win64MasterMasterSteamPGO/`.
          2. Extract **all** files from `${{ env.ARTIFACT_NAME }}` to `<GameDir>/Bin/Win64MasterMasterSteamPGO/`.
          3. Launch game. Default keys: F3 (Toggle View), Insert (Enable/Disable Free Camera).

          See the [README]($repoUrl/blob/main/TPVToggle/README.md) for details.
          "@
          Set-Content -Path "release_body.txt" -Value $releaseBody -Encoding UTF8
          echo "RELEASE_BODY_PATH=release_body.txt" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      # 12. Create/Publish GitHub Release
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ env.ARTIFACT_NAME }}
          name: KCD2 TPVToggle ${{ env.VERSION_TAG }} # Release title
          tag_name: TPVToggle-${{ env.VERSION_TAG }} # Use the specific tag prefix
          body_path: ${{ steps.prepare-release.outputs.RELEASE_BODY_PATH }} # File containing release notes
          draft: false # Publish immediately (set to true for draft)
          prerelease: ${{ inputs.prerelease }} # Use workflow input

      # 13. Archive Completed Changelog and Reset Template
      - name: Archive NEXT_CHANGELOG.md
        if: success() # Only run if release creation succeeded
        run: |
          $nextChangelog = "TPVToggle\docs\NEXT_CHANGELOG.md"
          $archiveDir = "TPVToggle\docs\archive"
          if (-not (Test-Path $archiveDir -PathType Container)) { New-Item -Path $archiveDir -ItemType Directory | Out-Null }
          $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
          # Include version tag in archived filename for clarity
          $archivedFilename = "CHANGELOG_$( ${{ env.VERSION_TAG }} )_$timestamp.md"
          Move-Item -Path $nextChangelog -Destination "$archiveDir\$archivedFilename" -Force

          # Create new template for the *next* release's changes
          $template = @'
          ## [Title for next release]

          - Added: ...
          - Fixed: ...
          - Changed: ...
          '@
          Set-Content -Path $nextChangelog -Value $template -Encoding utf8

          # Commit the archive action
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add $nextChangelog "$archiveDir\$archivedFilename"
          # Commit only if files were actually added/changed
          if (-not (git diff --staged --quiet --exit-code)) {
            git commit -m "docs(TPVToggle): Archive changelog for ${{ env.VERSION_TAG }} and prep next"
            git push origin main
          } else {
            echo "No changelog archive changes to commit."
          }
        shell: pwsh
